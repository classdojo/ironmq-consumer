// Generated by CoffeeScript 1.6.3
(function() {
  var Consumer, DEFAULT, IronMQ, IronMQStub, Queue, debug, jobLog, _, _auth, _setupAdmin;

  IronMQ = require("iron_mq");

  IronMQStub = require("../test/stubs/ironmq");

  _ = require("lodash");

  debug = require("debug")("loop");

  jobLog = require("debug")("jobs");

  /*
    Dead simple DojoConsumer that interfaces with ironMq and passes messages back
    to workers.  The workers specify a RegEx pattern for the jobs they want to
    handle.
    
    Pattern matching happens in the order of workers registered.
  */


  DEFAULT = {
    consumer: {
      sleep: 20,
      parallel: 10
    },
    queue: {
      name: "jobs"
    }
  };

  Consumer = (function() {
    function Consumer(options) {
      options = _.merge(DEFAULT, options);
      this.__queue = new Queue(options.queue);
      this.__consumerOpts = options.consumer;
      this.__jobHandlers = [];
      this.__errors = {
        system: {},
        common: {}
      };
      if (options.admin) {
        _setupAdmin(options.admin);
      }
    }

    Consumer.prototype.register = function(job, worker) {
      return this.__jobHandlers[job] = worker;
    };

    Consumer.prototype.deregister = function(job) {
      return delete this.__jobHandlers[job];
    };

    /*
      An event loop using 1ms ticks.
    */


    Consumer.prototype.start = function(cb) {
      return this.__interval = setInterval(this._loop.bind(this), this.__consumerOpts.sleep);
    };

    Consumer.prototype.stop = function(cb) {
      return clearInterval(this.__interval);
    };

    Consumer.prototype.info = function(cb) {
      return console.log("Printing error information");
    };

    Consumer.prototype._loop = function() {
      var n,
        _this = this;
      n = this.__consumerOpts.parallel;
      return this.__queue.get({
        n: n
      }, function(err, jobs) {
        if (err) {
          return _this.__errors.system[new Date().toISOString()] = err;
        } else if (!_.isEmpty(jobs)) {
          jobLog("" + (JSON.stringify(jobs, null, 4)));
          return jobs.forEach(function(job) {
            var j, type, worker, _ref;
            type = job.body.type;
            if (!type) {
              return _this.__queue.error(job, new Error("Job Id " + job.id + " has no `type` field"));
            } else {
              _ref = _this.__jobHandlers;
              for (j in _ref) {
                worker = _ref[j];
                if (type.match(j)) {
                  return worker(job.body.data, function(err) {
                    if (err) {
                      return _this.__queue.error(job, err);
                    } else {
                      return _this.__queue.del(job);
                    }
                  });
                }
              }
            }
          });
        } else {
          return debug("No jobs. Sleeping for " + _this.__sleepTime + " ms");
        }
      });
    };

    return Consumer;

  })();

  /*
    abstracts away details of ironmq client
  */


  Queue = (function() {
    /*
    */

    function Queue(options) {
      var Client;
      if (!options.token || !options.projectId) {
        throw new Error("You must provide proper IronMQ credentials {queue: {token: '', projectId: ''}}");
      }
      if (!options.name) {
        throw new Error("You must initialize queue with a name");
      }
      if (options.env === "production") {
        Client = IronMQ.Client;
        this.__mq = new Client({
          token: options.token,
          project_id: options.projectId
        });
        this.__q = this.__mq.queue(options.name);
      } else {
        Client = IronMQStub.Client;
        this.__mq = new Client({
          token: options.token,
          project_id: options.projectId
        });
        this.__q = this.__mq.queue(options.name);
        if (options.messages) {
          this.__q.setMessages(options.messages);
        }
      }
    }

    /*
      delegates to ironmq client GET. Uses defaults options but can pass
      in options to override those.
    */


    Queue.prototype.get = function(options, cb) {
      var _this = this;
      if (_.isFunction(options)) {
        cb = options;
        options = {};
      }
      return this.__q.get(options, function(error, messages) {
        var e, message, _i, _len;
        if (error) {
          return cb(error);
        }
        if (!messages) {
          return cb(null, []);
        }
        if (!_.isArray(messages)) {
          messages = [messages];
        }
        for (_i = 0, _len = messages.length; _i < _len; _i++) {
          message = messages[_i];
          try {
            message.body = JSON.parse(message.body);
          } catch (_error) {
            e = _error;
            return cb(new Error("Bad json data message: " + message));
          }
        }
        return cb(null, messages);
      });
    };

    /*
      Delete from queue
    */


    Queue.prototype.del = function(job, cb) {
      cb = cb || function() {};
      return this.__q.del(job.id, cb);
    };

    /*
      Releases item to go back to queue
    */


    Queue.prototype.release = function(job, cb) {
      cb = cb || function() {};
      return this.__q.msg_release(job.id, {}, cb);
    };

    Queue.prototype.error = function(job, error, cb) {
      cb = cb || function() {};
      return this.release(job, cb);
    };

    return Queue;

  })();

  Consumer.Queue = Queue;

  _auth = function(opts) {
    return function(req, res, next) {
      if (auth.basic.username === opts.user && auth.basic.password === opts.password) {
        return next();
      } else {
        return res.json(401, {
          message: "Not Authorized"
        });
      }
    };
  };

  _setupAdmin = function(opts) {
    var server;
    server = restify.createServer();
    server.use(restify.authorizationParser());
    server.get({
      path: "/failed-jobs",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {
      return res.json(200, {});
    });
    server.get({
      path: "/failed-jobs/:id",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {});
    return server.del({
      path: "/failed-jobs/:id",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {});
  };

  module.exports = Consumer;

}).call(this);
