// Generated by CoffeeScript 1.6.3
(function() {
  var Consumer, DEFAULT_ADMIN_PORT, DEFAULT_OPTIONS, ErrorJournal, EventLoop, IronMQ, IronMQStub, Queue, jobLog, loopLog, restify, _, _auth, _setupAdmin;

  IronMQ = require("iron_mq");

  IronMQStub = require("stubs").IronMQ;

  _ = require("lodash");

  loopLog = require("debug")("loop");

  jobLog = require("debug")("jobs");

  restify = require("restify");

  EventLoop = require("./utils").EventLoop;

  /*
    Dead simple DojoConsumer that interfaces with ironMq and passes messages back
    to workers.  The workers specify a RegEx pattern for the jobs they want to
    handle.
    
    Pattern matching happens in the order of workers registered.
  */


  DEFAULT_OPTIONS = {
    consumer: {
      sleep: 1000,
      parallel: 10
    },
    queue: {
      name: "jobs"
    }
  };

  DEFAULT_ADMIN_PORT = 9876;

  Consumer = (function() {
    function Consumer(options) {
      this.errorJournal = {
        system: new ErrorJournal(),
        queue: new ErrorJournal()
      };
      options = _.merge({}, _.cloneDeep(DEFAULT_OPTIONS), {
        queue: {
          errorJournal: this.errorJournal.queue
        }
      }, options);
      this.queue = new Queue(options.queue);
      this.eventLoop = new EventLoop(options.consumer.sleep);
      this.eventLoop.on("tick", this._loop.bind(this));
      this.__consumerOpts = options.consumer;
      this.__jobHandlers = [];
      this.processed = 0;
      if (options.admin) {
        _setupAdmin(options.admin, this);
      }
    }

    Consumer.prototype.register = function(job, worker) {
      return this.__jobHandlers[job] = worker;
    };

    Consumer.prototype.deregister = function(job) {
      return delete this.__jobHandlers[job];
    };

    /*
      An event loop using 1ms ticks.
    */


    Consumer.prototype.start = function(cb) {
      return this.eventLoop.start();
    };

    Consumer.prototype.stop = function(cb) {
      this.eventLoop.stop();
      if (this.server) {
        return this.server.close(cb);
      } else {
        return cb();
      }
    };

    Consumer.prototype.info = function(cb) {
      return console.log("Printing error information");
    };

    Consumer.prototype._loop = function() {
      var n,
        _this = this;
      n = this.__consumerOpts.parallel;
      return this.queue.get({
        n: n
      }, function(err, jobs) {
        if (err) {
          return _this.errorJournal.system.add(new Date().toISOString(), err);
        } else if (!_.isEmpty(jobs)) {
          jobLog("" + (JSON.stringify(jobs, null, 4)));
          return jobs.forEach(function(job) {
            var j, service, worker, _ref;
            if (_this.errorJournal.queue.contains(job.id)) {
              return _this.queue.release(job, function(err) {
                if (err) {
                  return _this.errorJournal.system.add(new Error("Problem releasing an already errored out job " + (err.message || err)));
                }
              });
            } else {
              service = job.body.service;
              if (!service) {
                return _this.queue.error(job, new Error("Job Id " + job.id + " has no `service` field"));
              } else {
                _ref = _this.__jobHandlers;
                for (j in _ref) {
                  worker = _ref[j];
                  if (service.match(j)) {
                    return worker(_.omit(job.body, "service"), function(err) {
                      var errorMessage;
                      if (err) {
                        errorMessage = err.message || err;
                        _this.errorJournal.queue.add(job.id, {
                          job: job,
                          error: errorMessage
                        });
                        return _this.queue.error(job, err);
                      } else {
                        _this.processed++;
                        return _this.queue.del(job);
                      }
                    });
                  }
                }
              }
            }
          });
        } else {
          return loopLog("No jobs. Sleeping for " + _this.__sleepTime + " ms");
        }
      });
    };

    return Consumer;

  })();

  /*
    abstracts away details of ironmq client
  */


  Queue = (function() {
    /*
    */

    function Queue(options) {
      var Client, config, releaseTime;
      if (!options.token || !options.projectId) {
        throw new Error("You must provide proper IronMQ credentials {queue: {token: '', projectId: ''}}");
      }
      if (!options.name) {
        throw new Error("You must initialize queue with a name");
      }
      if (!options.errorJournal) {
        throw new Error("You must include an instance of ErrorJournal");
      }
      this.__errorJournal = options.errorJournal;
      if (options.env === "production") {
        Client = IronMQ.Client;
        config = {
          token: options.token,
          project_id: options.projectId
        };
        if (options.host != null) {
          config.host = options.host;
        }
        this.__mq = new Client(config);
        this.__q = this.__mq.queue(options.name);
      } else {
        Client = IronMQStub.Client;
        this.__mq = new Client({
          token: options.token,
          project_id: options.projectId
        });
        releaseTime = options.releaseTime ? [options.releaseTime] : [];
        this.__q = this.__mq.queue.apply(this.__mq, [options.name].concat(releaseTime));
        if (options.messages) {
          this.__q.setMessages(options.messages);
        }
      }
    }

    /*
      delegates to ironmq client GET. Uses defaults options but can pass
      in options to override those.
    */


    Queue.prototype.get = function(options, cb) {
      var _this = this;
      if (_.isFunction(options)) {
        cb = options;
        options = {};
      }
      return this.__q.get(options, function(error, messages) {
        var e, message, returnThese, _i, _len;
        if (error) {
          return cb(error);
        }
        if (!messages) {
          return cb(null, []);
        }
        if (!_.isArray(messages)) {
          messages = [messages];
        }
        returnThese = [];
        for (_i = 0, _len = messages.length; _i < _len; _i += 1) {
          message = messages[_i];
          try {
            message.body = JSON.parse(message.body);
            returnThese.push(message);
          } catch (_error) {
            e = _error;
            _this.__errorJournal.add(message.id, new Error("Bad json data for message: " + (JSON.stringify(message.body, null, 4))));
          }
        }
        return cb(null, returnThese);
      });
    };

    /*
      Delete from queue
    */


    Queue.prototype.del = function(job, cb) {
      cb = cb || function() {};
      return this.__q.del(job.id, cb);
    };

    /*
      Releases item to go back to queue
    */


    Queue.prototype.release = function(job, cb) {
      cb = cb || function() {};
      return this.__q.msg_release(job.id, {}, cb);
    };

    Queue.prototype.error = function(job, error, cb) {
      cb = cb || function() {};
      return this.release(job, cb);
    };

    /*
      Hook for testing. Simply dumps the messages from the ironmq stub.
    */


    Queue.prototype.dump = function() {
      return this.__q.dump();
    };

    return Queue;

  })();

  /*
    Just a collection of errors. Used by Consumer and required by Queue.
  */


  ErrorJournal = (function() {
    function ErrorJournal() {
      this.__journal = {};
    }

    ErrorJournal.prototype.contains = function(id) {
      return this.__journal[id];
    };

    ErrorJournal.prototype.add = function(id, message) {
      return this.__journal[id] = message;
    };

    ErrorJournal.prototype.get = function(id) {
      return this.__journal[id];
    };

    ErrorJournal.prototype.del = function(id) {
      return delete this.__journal[id];
    };

    ErrorJournal.prototype.reset = function() {
      return this.__journal = {};
    };

    ErrorJournal.prototype.dump = function() {
      return this.__journal;
    };

    ErrorJournal.prototype.print = function() {
      return JSON.stringify(this.__journal, null, 4);
    };

    return ErrorJournal;

  })();

  /*
    Expose for testing
  */


  Consumer.ErrorJournal = ErrorJournal;

  Consumer.Queue = Queue;

  _auth = function(opts) {
    return function(req, res, next) {
      var auth;
      auth = req.authorization;
      if ((auth != null ? auth.basic : void 0) && auth.basic.username === opts.user && auth.basic.password === opts.password) {
        return next();
      } else {
        return res.json(401, {
          message: "Not Authorized"
        });
      }
    };
  };

  _setupAdmin = function(opts, consumer) {
    var server, start;
    start = new Date();
    server = restify.createServer();
    server.use(restify.authorizationParser());
    server.get({
      path: "/failed-jobs",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {
      var queue, system;
      queue = consumer.errorJournal.queue.dump();
      system = consumer.errorJournal.system.dump();
      return res.json(200, {
        queue: queue,
        system: system
      });
    });
    server.get({
      path: "/failed-jobs/:id",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {
      if (!consumer.errorJournal.queue.contains(req.params.id)) {
        return res.json(404, {
          status: "Not found"
        });
      }
      return res.json(200, consumer.errorJournal.queue.get(req.params.id));
    });
    server.del({
      path: "/failed-jobs/:id",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {
      if (!consumer.errorJournal.queue.contains(req.params.id)) {
        return res.json(404, {
          status: "Not found"
        });
      }
      consumer.errorJournal.queue.del(req.params.id);
      return consumer.queue.del({
        id: req.params.id
      }, function(err) {
        if (err != null) {
          return res.json(500, {
            status: err.message
          });
        } else {
          return res.json(200, {
            status: "Success"
          });
        }
      });
    });
    server.post({
      path: "/failed-jobs/:id/retry",
      verions: "0.0.1"
    }, _auth(opts), function(req, res) {
      if (!consumer.errorJournal.queue.contains(req.params.id)) {
        return res.json(404, {
          status: "Not found"
        });
      }
      consumer.errorJournal.queue.del(req.params.id);
      return res.json(200, {
        status: "Success"
      });
    });
    server.get({
      path: "/status",
      version: "0.0.1"
    }, _auth(opts), function(req, res) {
      var r;
      r = {
        upSince: start.toISOString(),
        jobsProcessed: consumer.processed,
        errors: {
          system: Object.keys(consumer.errorJournal.system.dump()).length,
          queue: Object.keys(consumer.errorJournal.queue.dump()).length
        }
      };
      return res.json(200, r);
    });
    server.listen(opts.port || DEFAULT_ADMIN_PORT);
    return consumer.server = server;
  };

  module.exports = Consumer;

}).call(this);
