// Generated by CoffeeScript 1.6.3
(function() {
  var Consumer, IronMQ, IronMQStub, Queue, debug, _;

  IronMQ = require("iron_mq");

  IronMQStub = require("../test/stubs/ironmq");

  _ = require("lodash");

  debug = require("debug")("loop");

  /*
    Dead simple DojoConsumer that interfaces with ironMq and passes messages back
    to workers.  The workers specify a RegEx pattern for the jobs they want to
    handle.
    
    Pattern matching happens in the order of workers registerd.
  */


  /*
    worker1Script = require("./workers/script1")
  
    consumer = new Consumer({project: "", token: "", env: "production"})
    consumer.register "job", worker1Script
    consumer.start()
  */


  /*
    Loop is the arbiter between the queue and our internal workers.
  
  
    queue ---> Loop pulls using consumer ---> Loop delegates to Proper Item --->
    Loop removes from queue on success/Handles error appropriately --> Repeat
  
    There can essentially be some
  */


  Consumer = (function() {
    function Consumer(options) {
      this.__queue = new Queue(options);
      this.__sleepTime = options.sleep || 20;
      this.__jobHandlers = [];
      this.__errors = {
        count: 0,
        errors: []
      };
    }

    Consumer.prototype.register = function(job, worker) {
      return this.__jobHandlers[job] = worker;
    };

    Consumer.prototype.deregister = function(job) {
      return delete this.__jobHandlers[job];
    };

    /*
      An event loop using 1ms ticks.
    */


    Consumer.prototype.start = function(cb) {
      return this.__interval = setInterval(this._loop.bind(this), this.__sleepTime);
    };

    Consumer.prototype.stop = function(cb) {
      return clearInterval(this.__interval);
    };

    Consumer.prototype.info = function(cb) {
      return console.log("Printing error information");
    };

    Consumer.prototype._loop = function() {
      var _this = this;
      return this.__queue.get(function(err, jobs) {
        if (err != null) {
          _this.__errors.count++;
          return _this.__errors.push(errors);
        } else if (!_.isEmpty(jobs)) {
          debug("Got jobs " + (JSON.stringify(jobs, null, 4)));
          return jobs.forEach(function(job) {
            var j, type, worker, _ref;
            type = job.body.type;
            if (type == null) {
              _this.__errors.count++;
              _this.__errors.push(new Error("Job Id " + job.id + " has not `type` field"));
              return _this.__queue.error(job);
            } else {
              _ref = _this.__jobHandlers;
              for (j in _ref) {
                worker = _ref[j];
                if (type.match(j)) {
                  return worker(job.body.data, function(err) {
                    if (err != null) {
                      return _this.__queue.error(job);
                    } else {
                      return _this.__queue.del(job);
                    }
                  });
                }
              }
            }
          });
        } else {
          return debug("No jobs. Sleeping for " + _this.__sleepTime + " ms");
        }
      });
    };

    return Consumer;

  })();

  /*
  { id: '5942486501293943295',
    body: '{"type":"mailgun:update_list","data":{"list":"teachers@classdojo.mailgun.org","memberId":"corey.brady@peelsb.com","body":{"address":"corey.brady@peelsb.com","name":"Mr. Corey Brady","vars":{"title":"Mr.","first_name":"Corey","last_name":"Brady"}}},"created":"\\"2013-11-04T19:22:37.423Z\\"","attempts":0}',
    timeout: 60,
    reserved_count: 1,
    push_status: {} }
  */


  /*
    abstracts away details of ironmq client
  */


  Queue = (function() {
    /*
    */

    function Queue(options) {
      var Client;
      if (!options.token || !options.projectId) {
        throw new Error("You must provide proper IronMQ credentials {token: '', projectId: ''}");
      }
      if (!options.queueName) {
        throw new Error("You must initialize queue with a name");
      }
      if (options.env === "production") {
        Client = IronMQ.Client;
        this.__mq = new Client({
          token: options.token,
          project_id: options.projectId
        });
        this.__q = this.__mq.queue(options.queueName);
      } else {
        Client = IronMQStub.Client;
        this.__mq = new Client({
          token: options.token,
          project_id: options.projectId
        });
        this.__q = this.__mq.queue(options.queueName);
        if (options.messages) {
          this.__q.setMessages(options.messages);
        }
      }
    }

    /*
      delegates to ironmq client GET. Uses defaults options but can pass
      in options to override those.
    */


    Queue.prototype.get = function(options, cb) {
      var _this = this;
      if (_.isFunction(options)) {
        cb = options;
        options = {};
      }
      return this.__q.get(options, function(error, messages) {
        var e, message, _i, _len;
        if (error) {
          return cb(error);
        }
        if (!messages) {
          return cb(null, []);
        }
        if (!_.isArray(messages)) {
          messages = [messages];
        }
        for (_i = 0, _len = messages.length; _i < _len; _i++) {
          message = messages[_i];
          try {
            message.body = JSON.parse(message.body);
          } catch (_error) {
            e = _error;
            return cb(new Error("Bad json data message: " + message));
          }
        }
        return cb(null, messages);
      });
    };

    /*
      Delete from queue
    */


    Queue.prototype.del = function(job, cb) {
      cb = cb || function() {};
      return this.__q.del(job.id, cb);
    };

    /*
      Releases item to go back to queue
    */


    Queue.prototype.release = function(job, cb) {
      cb = cb || function() {};
      return this.__q.msg_release(job.id, {}, cb);
    };

    Queue.prototype.error = function(job, cb) {
      cb = cb || function() {};
      return this.release(job, cb);
    };

    return Queue;

  })();

  Consumer.Queue = Queue;

  module.exports = Consumer;

}).call(this);
